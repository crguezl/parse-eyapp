=head1 NAME
 
Parse::Eyapp::datagenerationtut - Tutorial on Using Parse::Eyapp as a Data Generator for Testing
 
=head1 Introduction

Where parsing is the process of determination of a string's membership in a language, 
the process can also be reversed. Using a context free grammar it is possible to generate 
strings in the language described by that grammar.

Context free grammars can be used to generate tests. The programmer designs a grammar that
defines a set of inputs that will be able to find some set of bugs.

This tutorial shows how to use Parse::Eyapp to generate phrases belonging to the language
defined by a given grammar. We will generate inputs to test a simple calculator.
The pure grammar of the generator is:

  lusasoft@LusaSoft:~/src/perl/Parse-Eyapp/examples/generator$ eyapp -c Generator.eyp
  # file: Generator.eyp
  # compile with: eyapp -b '' Generator.eyp
  # then run: ./Generator.pm
  %strict
  %token NUM VARDEF VAR
  %right '='
  %left '-' '+'
  %left '*' '/'
  %left NEG
  %right '^'

  %%

  stmts:
        stmt
      | stmts ';'  stmt
  ;
  stmt:
        VARDEF '=' exp
  ;
  exp:
        NUM
      | VAR
      | exp '+' exp
      | exp '-' exp
      | exp '*' exp
      | exp '/' exp
      | '-'  exp %prec NEG
      | exp '^' exp
      | '('  exp ')'
  ;

  %%

First we compile the grammar with option C<-b ''> to produce a modulino:

  lusasoft@LusaSoft:~/src/perl/Parse-Eyapp/examples/generator$ eyapp -b '' Generator.eyp

Now, the module has execution permits and its first line contains the C<#!> header:

  lusasoft@LusaSoft:~/src/perl/Parse-Eyapp/examples/generator$ ls -ltr | tail -1
  -rwxr-xr-x 1 lusasoft lusasoft 7844 2009-01-12 08:30 Generator.pm
  lusasoft@LusaSoft:~/src/perl/Parse-Eyapp/examples/generator$ head -1 Generator.pm
  #!/usr/bin/perl

The use of option C<-b ''> combined with the fact that we have added these lines 

    67  unless (caller) {
    68    __PACKAGE__->main(@ARGV);
    69  }

at the end of the grammar file C<Generator.eyp> provide the generated file
with a dual nature: it is a module and an executable at the same time. This is
what is know as a modulino (term coined by Brian d Foy).

Here follows the results of several executions. Each run produces
a set of assignments. The first output line reports the result 
of the randomly generated program. 

  lusasoft@LusaSoft:~/src/perl/Parse-Eyapp/examples/generator$ ./Generator.pm
  # result: -3
  SC=-3

  # result: error. Division by zero.
  M=(-4/6+4)+9+2*8*9+4;
  XQ=8/3;
  EI=XQ*2/0/0;
  BL=5+EI+4/5/XQ

  lusasoft@LusaSoft:~/src/perl/Parse-Eyapp/examples/generator$ ./Generator.pm

  # result: 6
  CF=(6)

  lusasoft@LusaSoft:~/src/perl/Parse-Eyapp/examples/generator$ ./Generator.pm

  # result: -710.2
  I=(3*-8+7/5);
  R=2+8*I*4+5*2+I/I

  lusasoft@LusaSoft:~/src/perl/Parse-Eyapp/examples/generator$ ./Generator.pm

  # result: Calculator syntax differs from Perl... 
  RY=2--2+(3+6)+(7*7*4^1+2*0/8*5/3)

The examples for this tutorial can be found in the directory 
C<examples/generator> in the distribution of C<Parse::Eyapp>.

To understand the code you will need some familiarity with L<Test::LectroTest::Generator>.

=head1 Generating Phrases from a Context Free Grammar

The basic idea of using Parse::Eyapp to generate phrases for the language
defined by a given context free grammar is simple: change the lexer. Instead of 
reading from some input, randoml√±y generate one of the valid tokens. 
We can use the method C<YYExpect> to know what tokens are valid. 
For versions 1.137 and later of Parse::Eyapp The method C<YYExpect> returns
the set of valid tokens at the time it is called.
For previous versions (and this is true for L<Parse::Yapp>), C<YYExpect> only returns
a subset of the whole set of valid tokens). In this example, the token
generator has been isolated in the sub C<gen_lexer> in the file C<GenSupport.pm>:

    47  sub gen_lexer {
    48    my $parser = shift;
    49
    50    my $token = $parser->generate_token;
    51    my $attr = $parser->generate_attribute($token);
    52    #$attr = $WHITESPACES->generate.$attr;
    53
    54    return ($token, $attr);
    55  }

The token and its attribute are generated in lines 50 and 51.
The methods C<generate_token> and C<generate_attribute> are also
in the module C<GenSupport.pm>. They are methods of the 
parser object since the grammar C<Generator.eyp> not only uses but inherits
this module. See line 3 below:

  lusasoft@LusaSoft:~/src/perl/Parse-Eyapp/examples/generator$ sed -ne '19,24p' Generator.eyp | cat -n
     1  %{
     2  use base q{Parse::Eyapp::TokenGen};
     3  use base q{GenSupport};
     4  %}
     5
     6  %%

The method C<generate_token> obtains the set of valid tokens using C<YYExpect> (line 29).
Then uses the C<Frequency> function in L<Test::LectroTest::Generator> to produce 
a C<Test::LectroTest::Generator> object (line 31). The method C<generate> of such object
is used to generate the actual token (line 33).


    26  sub generate_token {
    27    my $parser = shift;
    28
    29    my @token = $parser->YYExpect;
    30
    31    my $tokengen = Frequency( map { [$parser->token_weight($_), Unit($_)] } @token);
    32
    33    return $tokengen->generate;
    34  }

The L<Parse::Eyapp::TokenGen> method C<token_weight> returns the weight 
associated with such token, that was previously set using one of
the L<Parse::Eyapp::TokenGen> methods C<set_tokenweightsandgenerators>
or C<set_tokenweights>.

Once the token is fixed, tha associated attribute is generated using
the generator associated with such token:

    36  sub generate_attribute {
    37    my $parser = shift;
    38    my $token = shift;
    39
    40    my $gen = $parser->token_generator($token);
    41    return $gen->generate  if defined($gen);
    42    return $token;
    43  }
    44
    45  #my $WHITESPACES = String( length=>[0,1], charset=>" \t\n", size => 100 );
       
=head1 Appendix: Files

=head2 File C<GenSupport.pm>

  lusasoft@LusaSoft:~/src/perl/Parse-Eyapp/examples/generator$ cat -n GenSupport.pm
     1  package GenSupport;
     2  use strict;
     3  use warnings;
     4
     5  use Getopt::Long;
     6  use Test::LectroTest::Generator qw(:all);
     7  use Parse::Eyapp::TokenGen;
     8
     9  sub _Error {
    10    my $parser = shift;
    11
    12    my $t = $parser->YYCurval;
    13    my @e = $parser->YYExpect();
    14    my $attr = $parser->YYSemval(0);
    15    local $" = " ";
    16    warn "Error:\nCurrent attribute: <$attr>\nCurrent token: <$t>\nExpected: <@e>\n";
    17  }
    18
    19  my %st; # Symbol Table
    20  sub defined_variable {
    21    my ($parser, $var) = @_;
    22
    23    $st{$var} = 1;
    24  }
    25
    26  sub generate_token {
    27    my $parser = shift;
    28
    29    my @token = $parser->YYExpect;
    30
    31    my $tokengen = Frequency( map { [$parser->token_weight($_), Unit($_)] } @token);
    32
    33    return $tokengen->generate;
    34  }
    35
    36  sub generate_attribute {
    37    my $parser = shift;
    38    my $token = shift;
    39
    40    my $gen = $parser->token_generator($token);
    41    return $gen->generate  if defined($gen);
    42    return $token;
    43  }
    44
    45  #my $WHITESPACES = String( length=>[0,1], charset=>" \t\n", size => 100 );
    46
    47  sub gen_lexer {
    48    my $parser = shift;
    49
    50    my $token = $parser->generate_token;
    51    my $attr = $parser->generate_attribute($token);
    52    #$attr = $WHITESPACES->generate.$attr;
    53
    54    return ($token, $attr);
    55  }
    56
    57  sub evaluate_using_perl { # if possible
    58    my $perlexp = shift;
    59
    60    $perlexp =~ s/\b([a-zA-Z])/\$$1/g; # substitute A by $A everywhere
    61    $perlexp =~ s/\^/**/g;             # substitute power operator: ^ by **
    62
    63    my $res = eval "no warnings; no strict;$perlexp";
    64    if ($@ =~ /Illegal division/) {
    65      $res = "error. Division by zero.";
    66    }
    67    elsif ($@) { # Our calc notation is incompatible with perl in a few gotchas
    68      # Perl interprets -- in a different way
    69      $@ =~ m{(.*)}; # Show only the first line of error message
    70      $res = "Calculator syntax differs from Perl. Can't compute the result: $1";
    71    }
    72
    73    $res;
    74  }
    75
    76
    77  sub Run {
    78      my($self)=shift;
    79      my $yydebug = shift || 0;
    80
    81      return $self->YYParse(
    82        yylex => \&gen_lexer,
    83        yyerror => \&_Error,
    84        yydebug => $yydebug, # 0x1F
    85      );
    86  }
    87
    88  sub main {
    89    my $package = shift;
    90
    91    my $debug = shift || 0;
    92    my $result = GetOptions (
    93      "debug!" => \$debug,
    94    );
    95
    96    $debug = 0x1F if $debug;
    97
    98    my $parser = $package->new();
    99
   100    $parser->set_tokenweightsandgenerators(
   101      NUM => [ 2, Int(range=>[0, 9], sized=>0)],
   102      VAR => [
   103                0,  # At the beginning, no variables are defined
   104                Gen {
   105                  return  Elements(keys %st)->generate if keys %st;
   106                  return Int(range=>[0, 9], sized=>0)->generate;
   107                },
   108              ],
   109      VARDEF => [
   110                  2,
   111                  String( length=>[1,2], charset=>"A-NP-Z", size => 100 )
   112                ],
   113      '=' => 2, '-' => 1, '+' => 2,
   114      '*' => 4, '/' => 2, '^' => 0.5,
   115      ';' => 1, '(' => 1, ')' => 2,
   116      ''  => 2, 'error' => 0,
   117    );
   118
   119    my $exp = $parser->Run( $debug );
   120
   121    my $res = evaluate_using_perl($exp);
   122
   123    print "\n# result: $res\n$exp\n";
   124  }
   125
   126  1;


=head2 File C<Generator.eyp>

  lusasoft@LusaSoft:~/src/perl/Parse-Eyapp/examples/generator$ cat -n Generator.eyp
     1  # file: Generator.eyp
     2  # compile with: eyapp -b '' Generator.eyp
     3  # then run: ./Generator.pm
     4  %strict
     5  %token NUM VARDEF VAR
     6
     7  %right  '='
     8  %left   '-' '+'
     9  %left   '*' '/'
    10  %left   NEG
    11  %right  '^'
    12
    13  %defaultaction {
    14    my $parser = shift;
    15
    16    return join '', @_;
    17  }
    18
    19  %{
    20  use base q{Parse::Eyapp::TokenGen};
    21  use base q{GenSupport};
    22  %}
    23
    24  %%
    25
    26  stmts:
    27      stmt
    28        {
    29          $_[0]->deltaweight(VAR => +1); # At least one variable is defined now
    30          $_[1];
    31        }
    32    | stmts ';' { "\n" } stmt
    33  ;
    34
    35  stmt:
    36      VARDEF '=' exp
    37        {
    38          my $parser = shift;
    39          $parser->defined_variable($_[0]);
    40          "$_[0]=$_[2]";
    41        }
    42  ;
    43  exp:
    44      NUM
    45    | VAR
    46    | exp '+' exp
    47    | exp '-' exp
    48    | exp '*' exp
    49    | exp '/' exp
    50    | '-' { $_[0]->pushdeltaweight('-' => -1) } exp %prec NEG
    51        {
    52          $_[0]->popweight();
    53          "-$_[3]"
    54        }
    55    | exp '^' exp
    56    | '('   { $_[0]->pushdeltaweight('(' => -1, ')' => +1, '+' => +1, ); }
    57        exp
    58      ')'
    59        {
    60           $_[0]->popweight;
    61           "($_[3])"
    62        }
    63  ;
    64
    65  %%
    66
    67  unless (caller) {
    68    __PACKAGE__->main(@ARGV);
    69  }


=head1 SEE ALSO

=over

=item *  The Design and Implementation of a Grammar-based Data Generator (1992) 
by Peter M. Maurer, Software Practice and Experience 
http://www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/./vol22/issue3/spe756pm.pdf 

=item * yagg: an easy-to-use generator for structured test inputs
by David Coppit and Jiexin Lian.
ASE '05: Proceedings of the 20th IEEE/ACM international Conference on Automated software engineering.
2005, pages 356-359. http://search.cpan.org/perldoc?yagg::Tutorial

=item * 
Writing Randomly by Randall Schwartz. 
Linux Magazine Column 04 (Sep 1999). 
http://www.stonehenge.com/merlyn/LinuxMag/col04.html

=back

=head1 REFERENCES

=over

=item *
The classic Dragon's book I<Compilers: Principles, Techniques, and Tools> 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)

=item *
I<CS2121: The Implementation and Power of Programming Languages>
(See L<http://www.cs.man.ac.uk/~pjj>, L<http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and L<http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks

=item * Modules as Programs by Brian d Foy 
http://www252.pair.com/comdog/mastering_perl/Chapters/18.modulinos.html

=item * How a Script Becomes a Module on Perlmonks: http://www.perlmonks.org/index.pl?node_id=396759.
=back

[% PROCESS authorandcopyright %]


