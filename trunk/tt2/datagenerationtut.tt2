=head1 NAME
 
Parse::Eyapp::datagenerationtut - Tutorial on Using Parse::Eyapp as a Data Generator 
 
=head1 Tutorial

Where parsing is the process of determination of a string's membership in a language, 
the process can also be reversed. Using a context free grammar it is possible to generate 
strings in the language described by that grammar.

This tutorial shows how to use Parse::Eyapp to generate phrases belonging to the language
defined by a given grammar. The example used is -once more - a simple calculator:
Here you have the results of several executions. Each run produces
a set of assignments. The first output line reports the result 
of the randomly generated program:


  lusasoft@LusaSoft:~/src/perl/Parse-Eyapp/examples/generator$ eyapp -b '' Generator.eyp

  # result: -3
  SC=-3
  lusasoft@LusaSoft:~/src/perl/Parse-Eyapp/examples/generator$ ./Generator.pm

  # result: error. Division by zero.
  M=(-4/6+4)+9+2*8*9+4;
  XQ=8/3;
  EI=XQ*2/0/0;
  BL=5+EI+4/5/XQ
  lusasoft@LusaSoft:~/src/perl/Parse-Eyapp/examples/generator$ ./Generator.pm

  # result: 6
  CF=(6)
  lusasoft@LusaSoft:~/src/perl/Parse-Eyapp/examples/generator$ ./Generator.pm

  # result: -710.2
  I=(3*-8+7/5);
  R=2+8*I*4+5*2+I/I

  lusasoft@LusaSoft:~/src/perl/Parse-Eyapp/examples/generator$ ./Generator.pm

  # result: Calculator syntax differs from Perl... 
  RY=2--2+(3+6)+(7*7*4^1+2*0/8*5/3)
  lusasoft@LusaSoft:~/src/perl/Parse-Eyapp/examples/generator$ ./Generator.pm

The examples for this tutorial can be found in the directory 
C<examples/generator> in the distribution of C<Parse::Eyapp>.

=head2 File C<GenSupport.pm>

  lusasoft@LusaSoft:~/src/perl/Parse-Eyapp/examples/generator$ cat -n GenSupport.pm
     1  package GenSupport;
     2  use strict;
     3  use warnings;
     4
     5  use Getopt::Long;
     6  use Test::LectroTest::Generator qw(:all);
     7  use Parse::Eyapp::TokenGen;
     8
     9  sub _Error {
    10    my $parser = shift;
    11
    12    my $t = $parser->YYCurval;
    13    my @e = $parser->YYExpect();
    14    my $attr = $parser->YYSemval(0);
    15    local $" = " ";
    16    warn "Error:\nCurrent attribute: <$attr>\nCurrent token: <$t>\nExpected: <@e>\n";
    17  }
    18
    19  my %st; # Symbol Table
    20  sub defined_variable {
    21    my ($parser, $var) = @_;
    22
    23    $st{$var} = 1;
    24  }
    25
    26  sub generate_token {
    27    my $parser = shift;
    28
    29    my @token = $parser->YYExpect;
    30
    31    my $tokengen = Frequency( map { [$parser->weight($_), Unit($_)] } @token);
    32
    33    return $tokengen->generate;
    34  }
    35
    36  sub generate_attribute {
    37    my $parser = shift;
    38    my $token = shift;
    39
    40    my $gen = $parser->generator($token);
    41    return $gen->generate  if defined($gen);
    42    return $token;
    43  }
    44
    45  #my $WHITESPACES = String( length=>[0,1], charset=>" \t\n", size => 100 );
    46
    47  sub gen_lexer {
    48    my $parser = shift;
    49
    50    my $token = $parser->generate_token;
    51    my $attr = $parser->generate_attribute($token);
    52    #$attr = $WHITESPACES->generate.$attr;
    53
    54    return ($token, $attr);
    55  }
    56
    57  sub evaluate_using_perl { # if possible
    58    my $perlexp = shift;
    59
    60    $perlexp =~ s/\b([a-zA-Z])/\$$1/g; # substitute A by $A everywhere
    61    $perlexp =~ s/\^/**/g;             # substitute power operator: ^ by **
    62
    63    my $res = eval "no warnings; no strict;$perlexp";
    64    if ($@ =~ /Illegal division/) {
    65      $res = "error. Division by zero.";
    66    }
    67    elsif ($@) { # Our calc notation is incompatible with perl in a few gotchas
    68      # Perl interprets -- in a different way
    69      $@ =~ m{(.*)}; # Show only the first line of error message
    70      $res = "Calculator syntax differs from Perl. Can't compute the result: $1";
    71    }
    72
    73    $res;
    74  }
    75
    76
    77  sub Run {
    78      my($self)=shift;
    79      my $yydebug = shift || 0;
    80
    81      return $self->YYParse(
    82        yylex => \&gen_lexer,
    83        yyerror => \&_Error,
    84        yydebug => $yydebug, # 0x1F
    85      );
    86  }
    87
    88  sub main {
    89    my $package = shift;
    90
    91    my $debug = shift || 0;
    92    my $result = GetOptions (
    93      "debug!" => \$debug,
    94    );
    95
    96    $debug = 0x1F if $debug;
    97
    98    my $parser = $package->new();
    99
   100  #  $parser->set_tokengens(
   101  #     NUM         => Int(range=>[0, 9], sized=>0),
   102  #     VARDEF      => String( length=>[1,2], charset=>"A-NP-Z", size => 100 ),
   103  #     VAR         => Gen {
   104  #                      return  Elements(keys %st)->generate if keys %st;
   105  #                      return Int(range=>[0, 9], sized=>0)->generate;
   106  #                    },
   107  #  );
   108  #
   109  #  $parser->set_weights(
   110  #    NUM => 2,
   111  #    VAR => 0, # At the beginning, no variables are defined
   112  #    VARDEF => 2,
   113  #    '=' => 2,
   114  #    '-' => 1,
   115  #    '+' => 2,
   116  #    '*' => 4,
   117  #    '/' => 2,
   118  #    '^' => 0.5,
   119  #    ';' => 1,
   120  #    '(' => 1,
   121  #    ')' => 2,
   122  #    ''  => 2,
   123  #    'error' => 0,
   124  #  );
   125
   126    $parser->set_weights_and_generators(
   127      NUM => [ 2, Int(range=>[0, 9], sized=>0)],
   128      VAR => [
   129                0,  # At the beginning, no variables are defined
   130                Gen {
   131                  return  Elements(keys %st)->generate if keys %st;
   132                  return Int(range=>[0, 9], sized=>0)->generate;
   133                },
   134              ],
   135      VARDEF => [
   136                  2,
   137                  String( length=>[1,2], charset=>"A-NP-Z", size => 100 )
   138                ],
   139      '=' => 2,
   140      '-' => 1,
   141      '+' => 2,
   142      '*' => 4,
   143      '/' => 2,
   144      '^' => 0.5,
   145      ';' => 1,
   146      '(' => 1,
   147      ')' => 2,
   148      ''  => 2,
   149      'error' => 0,
   150    );
   151
   152    my $exp = $parser->Run( $debug );
   153
   154    my $res = evaluate_using_perl($exp);
   155
   156    print "\n# result: $res\n$exp\n";
   157  }
   158
   159  1;

=head2 File C<Generator.eyp>

  lusasoft@LusaSoft:~/src/perl/Parse-Eyapp/examples/generator$ cat -n Generator.eyp
     1  # file: Generator.eyp
     2  # compile with: eyapp -b '' Generator.eyp
     3  # then run: ./Generator.pm
     4  %strict
     5  %token NUM VARDEF VAR
     6
     7  %right  '='
     8  %left   '-' '+'
     9  %left   '*' '/'
    10  %left   NEG
    11  %right  '^'
    12
    13  %defaultaction {
    14    my $parser = shift;
    15
    16    return join '', @_;
    17  }
    18
    19  %{
    20  use base q{Parse::Eyapp::TokenGen};
    21  use base q{GenSupport};
    22  %}
    23
    24  %%
    25
    26  stmts:
    27      stmt
    28        {
    29          $_[0]->deltaweight(VAR => +1); # At least one variable is defined now
    30          $_[1];
    31        }
    32    | stmts ';' { "\n" } stmt
    33  ;
    34
    35  stmt:
    36      VARDEF '=' exp
    37        {
    38          my $parser = shift;
    39          $parser->defined_variable($_[0]);
    40          "$_[0]=$_[2]";
    41        }
    42  ;
    43  exp:
    44      NUM
    45    | VAR
    46    | exp '+' exp
    47    | exp '-' exp
    48    | exp '*' exp
    49    | exp '/' exp
    50    | '-' { $_[0]->pushdeltaweight('-' => -1) } exp %prec NEG
    51        {
    52          $_[0]->popweight();
    53          "-$_[3]"
    54        }
    55    | exp '^' exp
    56    | '('   { $_[0]->pushdeltaweight('(' => -1, ')' => +1, '+' => +1, ); }
    57        exp
    58      ')'
    59        {
    60           $_[0]->popweight;
    61           "($_[3])"
    62        }
    63  ;
    64
    65  %%
    66
    67  unless (caller) {
    68    my $exp;
    69    __PACKAGE__->main(@ARGV);
    70  }
    71

=head1 SEE ALSO

=over

=item *  The Design and Implementation of a Grammar-based Data Generator (1992) 
by Peter M. Maurer, Software Practice and Experience 
http://www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/./vol22/issue3/spe756pm.pdf 

=item * yagg: an easy-to-use generator for structured test inputs
by David Coppit and Jiexin Lian.
ASE '05: Proceedings of the 20th IEEE/ACM international Conference on Automated software engineering.
2005, pages 356-359. http://search.cpan.org/perldoc?yagg::Tutorial

=item * 
Writing Randomly by Randall Schwartz. 
Linux Magazine Column 04 (Sep 1999). 
http://www.stonehenge.com/merlyn/LinuxMag/col04.html

=back

=head1 REFERENCES

=over

=item *
The classic Dragon's book I<Compilers: Principles, Techniques, and Tools> 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)

=item *
I<CS2121: The Implementation and Power of Programming Languages>
(See L<http://www.cs.man.ac.uk/~pjj>, L<http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and L<http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks

=back

[% PROCESS authorandcopyright %]


