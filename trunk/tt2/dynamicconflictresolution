=head1  SOLVING CONFLICTS WITH THE I<POSTPONED CONFLICT> STRATEGY

Yacc-like parser generators provide ways to solve shift-reduce mechanims
based on token precedence. No mechanisms are provided for the resolution
of reduce-reduce conflicts. The solution for such kind of conflicts is to modify
the grammar. The strategy I present here provides a way to broach conflicts
that can't be solved using static precedences.

=head2 Introduction: The C++ Ambiguity

The C++ syntax does not disambiguate between expression
statements and declaration statements. The ambiguity arises when an expression
statement has a function-style cast as its left-most subexpression. 
(Since C does not support function-style casts, this ambiguity does not occur
in C programs.) 

For example,

     int (x) = y+z;

parses as either an C<expr> or a C<stmt>.

If the statement can be interpreted both as a declaration and
as an expression, the statement is interpreted as a declaration statement. 

The following expressions disambiguate into expression statements because the
declarator is followed by an operator different from the assignment  operator. 

    type_spec(i)++;             // expression statement
    type_spec(i,3)<<d;          // expression statement
    type_spec(i)->l=24;         // expression statement

Where C<type_spec> stands for a type specifier.

In the following examples, the interpretation as declaration works, and
consequently the statements are interpreted as declarations:

    type_spec(*i)(int);         // declaration
    type_spec(j)[5];            // declaration
    type_spec(m) = { 1, 2 };    // declaration
    type_spec(a);               // declaration
    type_spec(*b)();            // declaration
    type_spec(c)=23;            // declaration
    type_spec(d),e,f,g=0;       // declaration
    type_spec(h)(e,3);          // declaration

=head2 An Ambiguous Grammar 

The simple grammar in C<examples/debuggingtut/SimplifiedCplusplusAmbiguity.eyp>
illustrates the problem of parsing C++:

  examples/debuggingtut$ eyapp -c SimplifiedCplusplusAmbiguity.eyp
  %strict
  %token ID INT NUM
  %right '='
  %left '+'

  %%

  prog:
        /* empty */
      | prog stmt
  ;
  stmt:
        expr ';'
      | decl
  ;
  expr:
        ID
      | NUM
      | INT '(' expr ')' /* typecast */
      | expr '+' expr
      | expr '=' expr
  ;
  decl:
        INT declarator ';'
      | INT declarator '=' expr ';'
  ;
  declarator:
        ID
      | '(' declarator ')'
  ;

  %%

The grammar is ambiguous since an input like:

               int (x) = 4;

can be interpreted as a C<decl> or an C<expr>.

The C<eyapp> compiler warn us of the presence of reduce/reduce conflict:

  examples/debuggingtut$ eyapp -v SimplifiedCplusplusAmbiguity.eyp
  1 reduce/reduce conflict

when we look at the C<.output> file we see that the reduce-reduce conflict
is at state 18:

  examples/debuggingtut$ head -12 SimplifiedCplusplusAmbiguity.output
  Warnings:
  ---------
  1 reduce/reduce conflict

  Conflicts:
  ----------
  Conflict in state 15 between rule 8 and token '+' resolved as reduce.
  Conflict in state 15 between rule 8 and token '=' resolved as reduce.
  Conflict in state 17 between rule 9 and token '+' resolved as shift.
  Conflict in state 17 between rule 9 and token '=' resolved as shift.
  State 18 contains 1 reduce/reduce conflict


When we look at the description of the involved state, we see the reasons for the conflict:

  examples/debuggingtut$ sed -ne '/^State 18:/,/^State/p' SimplifiedCplusplusAmbiguity.output
  State 18:

          expr -> ID .    (Rule 5)
          declarator -> ID .      (Rule 12)

          ')'     [reduce using rule 12 (declarator)]
          $default        reduce using rule 5 (expr)

  State 19:

The conflict means that once the parser has seen the C<ID> and is in the presence
of the closing parenthesis C<')'>, it is incapable to decide whether 
to reduce by rule 12 or rule 5.

As we said, the C++ disambiguation rule is: take it as a declaration if it looks as a declaration,
otherwise is an expression.  But we see that interpretation as C<decl> 
will succeed if declarator is followed - after the sequence of closing parenthesis - 
by one of the two tokens a C<;> or C<=>. That can be traced during
parsing time. L<Parse::Eyapp> provides the mechanisms to change the parsing
actions at parsing time.

=head2 The I<Postponed Conflict Resolution> Strategy

The I<postponed conflict strategy> presented here can be used whenever there 
is a shift-reduce or reduce-reduce conflict that can not be solved using static 
precedences but that can be solved using information obtained at parsing time.

=head2 I<Postponed Conflict Resolution>: Reduce-Reduce Conflicts

Let us assume we have a reduce-reduce conflict between to productions

                      A -> alpha .
                      B -> beta .

for some token C<@>. Let also assume that production 

                      A -> alpha

has name C<ruleA> and production

                      B -> beta 

has name C<ruleB>.

The postponed conflict resolution strategy consists
in modifying the conflictive grammar by adding at the points of conflict, 
in this case at then end of the involved productions a new syntactic variable
C<IsAorB>:

                      A -> alpha IsAorB .
                      B -> beta  IsAorB .

The reduce-reduce conflict is now I<postponed> after C<IsAorB> is seen.
The new syntactic variable C<IsAorB> will be called the I<conflict name>. 
The new introduced syntactic variable has only one empty production:

                     IsAorB -> /* empty */

The programmer associates with that production a semantic action
whose mission is to solve the conflict by dynamically changing the
parsing table like this:

                     IsAorB -> /* empty */ 
                       {
                          my $self = shift;

                          if (looks_like_A($self)) {
                            $self->YYSetReduce('@', 'ruleA' );
                          }
                          else {
                            $self->YYSetReduce('@', 'ruleB' );
                          }
                       }

The semantic action associated with the I<conflict name>
receives the name of I< conflict handler>.

=head2 An Example of Dynamic Conflict Resolution

The Eyapp program C<examples/debuggingtut/Cplusplus.eyp> solves the 
conflicts in  C<examples/debuggingtut/SimplifiedCplusplusAmbiguity.eyp> 
by using the I<Postponed Conflict Resolution> strategy:

  examples/debuggingtut$ head -67 Cplusplus.eyp | cat -n
     1  # See http://www.gnu.org/software/bison/manual/html_mono/bison.html#GLR-Parsers
     2  %strict
     3  %token ID INT NUM
     4
     5  %right '='
     6  %left '+'
     7
     8  %tree bypass
     9
    10  %expect 0 1 # 0 shift-reduce conflicts, 1 reduce-reduce conflict
    11
    12  %%
    13  prog:
    14      %name EMPTY
    15      /* empty */
    16    | %name PROG
    17      prog stmt
    18  ;
    19
    20  stmt:
    21      %name EXP
    22      expr ';'
    23    | %name DECL
    24      decl
    25  ;
    26
    27  expr:
    28      %name EXPID
    29      ID decexpconflict
    30    | %name NUM
    31      NUM
    32    | %name TYPECAST
    33      INT '(' expr ')' /* typecast */
    34    | %name PLUS
    35      expr '+' expr
    36    | %name ASSIGN
    37      expr '=' expr
    38  ;
    39
    40  decl:
    41      %name DECLARATOR
    42      INT declarator ';'
    43    | %name DECLARATORINIT
    44      INT declarator '=' expr ';'
    45  ;
    46
    47  declarator:
    48      %name DECID
    49      ID decexpconflict
    50    | '(' declarator ')'
    51  ;
    52
    53  decexpconflict:
    54      /* empty. Just to solve the reduce-reduce conflict */
    55        {
    56          my $self = shift;
    57
    58          if ($self->{INPUT} =~ m{^[)\s]*[;=]\s*}) {
    59            $self->YYSetReduce(')', 'DECID' );
    60          }
    61          else {
    62            $self->YYSetReduce(')', 'EXPID' );
    63          }
    64        }
    65  ;
    66
    67  %%


The aforementioned conflict in C<examples/debuggingtut/SimplifiedCplusplusAmbiguity.eyp>:

  examples/debuggingtut$ sed -ne '/^State 18:/,/^State/p' SimplifiedCplusplusAmbiguity.output
  State 18:

          expr -> ID .    (Rule 5)
          declarator -> ID .      (Rule 12)

          ')'     [reduce using rule 12 (declarator)]
          $default        reduce using rule 5 (expr)

  State 19:

is now delayed just after seen C<decexpconflict>:

  examples/debuggingtut$ eyapp -vb '' Cplusplus.eyp
  1 reduce/reduce conflict
  examples/debuggingtut$ sed -ne '/^State 27:/,/^State/p' Cplusplus.output
  State 27:

          expr -> ID decexpconflict .     (Rule 5)
          declarator -> ID decexpconflict .       (Rule 12)

          ')'     [reduce using rule 12 (declarator)]
          $default        reduce using rule 5 (expr)

  State 28:

The call 

         $self->YYSetReduce(')', 'DECID' );

inside the semantic action associated with C<decexpconflict> sets the parsing action
to reduce by the production with name C<DECID>, i.e.

            declarator -> ID 

when the incoming input is followed by a semicolon or an equal. Otherwise the action taken is 
to reduce by 

            expr -> ID

The program now successfully solves the ambiguity:

  examples/debuggingtut$ Cplusplus.pm
  int(x)+2;
  PROG(EMPTY,EXP(TYPECAST(TERMINAL[int],EXPID[x]),NUM[2]))
  debuggingtut$ Cplusplus.pm
  int(x)=2;
  PROG(EMPTY,DECL(TERMINAL[int],DECID[x],NUM[2]))
  examples/debuggingtut$ Cplusplus.pm
  int(x);
  PROG(EMPTY,DECL(TERMINAL[int],DECID[x]))

=head2 Using C<YYSetLRAction> and C<YYNextState>

The modulino C<glrexpressions.eyp> illustrates an alternative way to
apply the postponed conflict resolution strategy to the aforementioned
problem:

  examples/debuggingtut$ head -69 glrexpressions.eyp | cat -n
     1  # See http://www.gnu.org/software/bison/manual/html_mono/bison.html#GLR-Parsers
     2  %strict
     3  %token ID INT NUM
     4
     5  %right '='
     6  %left '+'
     7
     8  %{
     9  my $input;
    10  %}
    11
    12  %tree bypass
    13  %%
    14  prog:
    15      %name EMPTY
    16      /* empty */
    17    | %name PROG
    18      prog stmt
    19  ;
    20
    21  stmt:
    22      %name EXP
    23      expr ';'
    24    | %name DECL
    25      decl
    26  ;
    27
    28  expr:
    29      %name EXPID
    30      ID decexpconflict
    31    | %name NUM
    32      NUM
    33    | %name TYPECAST
    34      INT '(' expr ')' /* typecast */
    35    | %name PLUS
    36      expr '+' expr
    37    | %name ASSIGN
    38      expr '=' expr
    39  ;
    40
    41  decl:
    42      %name DECLARATOR
    43      INT declarator ';'
    44    | %name DECLARATORINIT
    45      INT declarator '=' expr ';'
    46  ;
    47
    48  declarator:
    49      %name DECID
    50      ID decexpconflict
    51    | '(' declarator ')'
    52  ;
    53
    54  decexpconflict:
    55      /* empty. Just for hacking the LALR tables */
    56        {
    57          my $self = shift;
    58
    59          my $conflictstate = $self->YYNextState();
    60          if ($input =~ m{^[)\s]*[;=]\s*}) {
    61            $self->YYSetLRAction($conflictstate, ')', 'DECID' );
    62          }
    63          else {
    64            $self->YYSetLRAction($conflictstate, ')', 'EXPID' );
    65          }
    66        }
    67  ;
    68
    69  %%


Line 59 uses the method C<YYNextState> to compute the state after the reduction for
the production rule 

      decexpconflict -> /* empty */

which is precisely the conflict state. If the incoming input is a sequence of parenthesis 
followed by either a semicolon or an equal we call to the method C<YYSetLRAction> to set
a reduction by the rule

     declarator -> ID

for that state and token C<')'>, otherwise we indicate a reduction by the rule:

     expr -> ID    


=head2 I<Postponed Conflict Resolution>: Shift-Reduce Conflicts

The program in C<examples/debuggingtut/DynamicallyChangingTheParser2.eyp> illustrates how the postponed
conflict strategy is used for shift-reduce conflicts.
This is an extension of the grammar in C<examples/debuggingtut/Debug.eyp>.
The generated language is constituted by sequences like:

    { D; D; S; S; S; } {D; S} { S }

As you remember the conflict was:

  ~/LEyapp/examples/debuggingtut$ sed -ne '/^St.*13:/,/^St.*14/p' DynamicallyChangingTheParser.output  
  State 13:

      ds -> D conflict . ';' ds   (Rule 6)
      ds -> D conflict .  (Rule 7)

      ';' shift, and go to state 16

      ';' [reduce using rule 7 (ds)]

  State 14:


The C<conflict> handler below sets the LR action
to reduce by the production with name C<D1>

                 ds -> D

in the presence of token C<';'> if indeed is the last C<'D'>, that is, if:

       ${$self->input()} =~ m{^\s*;\s*S}

Otherwise we set the C<shift> action via a call to the 
C<YYSetShift> method.

  ~/LEyapp/examples/debuggingtut$ sed -ne '30,$p' DynamicallyChangingTheParser.eyp | cat -n
     1  %token D S
     2  
     3  %tree bypass
     4  
     5  # Expect just 1 shift-reduce conflict
     6  %expect 1 
     7  
     8  %%
     9  p: %name PROG
    10      block +
    11  ;
    12  
    13  block:
    14      %name BLOCK_DS
    15      '{' ds ';' ss '}' 
    16    | %name BLOCK_S
    17      '{' ss '}'
    18  ;
    19  
    20  ds:
    21      %name D2
    22      D conflict ';' ds    
    23    | %name D1
    24      D conflict        
    25  ;
    26  
    27  ss:
    28      %name S2
    29      S ';' ss      
    30    | %name S1
    31      S       
    32  ;
    33  
    34  conflict:
    35        /* empty. This action solves the conflict using dynamic precedence */
    36        {
    37          my $self = shift;
    38  
    39          if (${$self->input()} =~ m{^\s*;\s*S}) {
    40            $self->YYSetReduce(';', 'D1' )
    41          }
    42          else {
    43            $self->YYSetShift(';')
    44          }
    45  
    46          undef; # skip this node in the AST
    47        }
    48  ;
    49  
    50  %%
    51  
    52  my $prompt = 'Provide a statement like "{D; S} {D; D; S}" and press <CR><CTRL-D>: ';
    53  __PACKAGE__->main($prompt) unless caller;

