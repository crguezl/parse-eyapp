Almost any Perl programmer knows what {\it Parsing} is about.
One of the strengths of Perl is its excellence for text analysis. 
Additionally to its embedded regular expression capacities, modules 
like \code{Parse::RecDescent} \cite{conwayrd} and 
\code{Parse::Yapp} \cite{desarmenien} make easier the task of text 
understanding and text transformation.
%This is in clear contrast with the absence of Perl 5 
%generic tools\footnote{There are however very good specific ones,
%for example, for \code{XML} and \code{HTML} support and 
%symbolic mathematics
% \cite{muller}
%}
%giving support for the subsequent stages
%of text processing.
%The exception being the module \code{Language::AttributeGrammar}
%\cite{luke}. Parrot does well in this 
%chapter, having the Parrot Grammar Engine (PGE) \cite{michaud}
%and the Tree Grammar Engine (TGE)
%\cite{randaltge}.

\cpan{Parse::Eyapp} (Extended yapp) is a collection of modules
that extends Francois Desarmenien \code{Parse::Yapp} \code{1.05}:
Any \code{yapp} program runs without changes with \code{eyapp}.
Additionally \cpan{Parse::Eyapp} provides new 
functionalities like named attributes,
EBNF-like expressions, modifiable default actions,
abstract syntax tree building and translation schemes. 
It also provides a language for tree transformations.

This article introduces the basics of 
translator construction with \cpan{Parse::Eyapp} through an
example that compiles infix expressions into Parrot 
Intermediate Representation (PIR)\cite{randal04}.
Parrot is a virtual machine (VM), similar to the Java VM and the
.NET VM. However, unlike these two which are designed for
statically-typed languages like Java or C\#, Parrot is designed for
use with dynamically typed languages such as Perl, Python, Ruby,
or PHP.

The input to the program will be a (semicolon separated)
list of infix expressions, like:

\begin{verbatim}
1  b = 5;
2  a = b+2;
3  a = 2*(a+b)*(2-4/2); # is zero
4  print a;
5  d = (a = a+1)*4-b;
6  c = a*b+d;
7  print c;
8  print d
\end{verbatim}

and the output is an equivalent
PIR: 
\begin{verbatim}
 1  .sub 'main' :main
 2     .local num a, b, c, d
 3     b = 5
 4     a = b + 2
 5     a = 0 # expression at line 3 
 6     print "a = "     # above was
 7     print a    # reduced to zero
 8     print "\n" # at compile time
 9     a = a + 1
10     $N5 = a * 4
11     d = $N5 - b
12     $N7 = a * b
13     c = $N7 + d
14     print "c = "
15     print c
16     print "\n"
17     print "d = "
18     print d
19     print "\n"
20  .end
\end{verbatim}

You can download the code for this example from
\htmladdnormallink
{http://nereida.deioc.ull.es/~pl/eyapsimple/source.tgz}
{http://nereida.deioc.ull.es/~pl/eyapsimple/source.tgz}.
To use it, unpack the tarball:
\begin{verbatim}
tar xvzf source.tgz
\end{verbatim}
Change to the directory:
\begin{verbatim}
cd src
\end{verbatim}
and compile the grammar with \verb|eyapp|:
\begin{verbatim}
eyapp Infix.eyp
\end{verbatim}
Compile also the set of tree transformations using \verb|treereg|:
\begin{verbatim}
treereg -m main I2PIR.trg
\end{verbatim}
After these two compilations we have two new modules:
\begin{verbatim}
nereida:/tmp/src> ls -ltr |tail -2
-rw-rw----  1 pl users   Infix.pm
-rw-rw----  1 pl users   I2PIR.pm
\end{verbatim}
Module \verb|Infix.pm| contains the parser for the grammar described in \verb|Infix.eyp|.
Module \verb|I2PIR.pm| contains the collection of tree transformations described
in \verb|I2PIR.trg|. Now we can run the script \verb|infix2pir.pl| which makes use of these
two modules:
\begin{verbatim}
$ ./infix2pir.pl input1.inf > input1.pir
\end{verbatim}
We can now make use of the \verb|parrot| interpreter to execute the code:
\begin{verbatim}
$ /Users/casianorodriguezleon/src/parrot/parrot-1.9.0/parrot input1.pir 
a = 0
c = 4
d = -1
\end{verbatim}

