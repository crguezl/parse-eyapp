# See: http://www.gnu.org/software/bison/manual/html_mono/bison.html#Lexical-Tie_002dins
# for a more detailed explanation.

%strict

%token ID HEX INT INTEGER 

%namingscheme {
  #Receives a Parse::Eyapp object describing the grammar
  my $self = shift;

  $self->tokennames(
    '=' => 'ASSIGN',
    '(' => 'LP',
    ')' => 'RP',
    '+' => 'PLUS',
  );

  # returns the handler that will give names
  # to the right hand sides
  \&give_rhs_name;
}

%right '='
%left '+'

%{
use Data::Dumper;
my $hexflag = 0; # make it an attribute
my %st;
%}

%tree

%%
stmt:
    decl <* ';'> expr <+ ';'>
      {
        $_[2];
      }
;

decl:
    INT ID <+ ','>
      {
        for ($_[2]->children()) {
          $st{$_->{attr}} = 1;
        }
      }
;

expr:
    ID
  | INTEGER
  | HEX '(' { $hexflag = 1; } expr ')'
      { 
        $hexflag = 0; 
        goto &Parse::Eyapp::Driver::YYBuildAST;
      }
  | ID '=' expr
  | expr '+' expr
;

%%

use Getopt::Long;
use List::Util qw{first};

sub _Error {
  my($token)=$_[0]->YYCurval;
  my($what)= $token ? "input: '$token'" : "end of input";
  my @expected = $_[0]->YYExpect();

  local $" = ', ';
  warn "Syntax error near $what. Expected one of these tokens: <@expected>\n";
  warn "Remaining input:\n". substr($_[0]->{input}, pos($_[0]->{input}));
  die Dumper($_[0]->{STACK});
}


# Context-dependant lexer
sub lexer {
  my $parser = shift;

  for ($parser->{input}) {    # contextualize
    m{\G\s*(\#.*)?}gc;

    m{\G(HEX\b|INT\b)}igc and return (uc($1), $1);

    m{(\G\d+)}gc and return ('INTEGER', $hexflag? hex($1) : $1);


    m{\G([a-zA-Z_]\w*)}gc and do {
      my $match = $1;
      $hexflag and !exists($st{$match}) and $match =~ m{\G([A-F0-9]+)}gc and return ('INTEGER', hex($match)); 
      return ('ID', $1);
    };

    m{\G(.)}gc         and return ($1, $1);

    return('',undef);
  }
}

sub Run {
    my($self)=shift;
    my $yydebug = shift || 0;

    return $self->YYParse( 
      yylex => \&lexer, 
      yyerror => \&_Error,
      yydebug => $yydebug, # 0x1F
    );
}

sub uploadfile {
  my $file = shift;
  my $msg = shift;

  my $input = '';
  eval {
    $input = Parse::Eyapp::Base::slurp_file($file) 
  };
  if ($@) {
    print $msg;
    local $/ = undef;
    $input = <STDIN>;
  }
  return $input;
}

sub main {
  my $package = shift;

  my $debug = 0;
  my $file = '';
  my $result = GetOptions (
    "debug!" => \$debug,  
    "file=s" => \$file,
  );

  $debug = 0x1F if $debug;
  $file = shift if !$file && @ARGV; 

  my $parser = $package->new();
  my $prompt = "Expressions. Press CTRL-D (Unix) or CTRL-Z (Windows) to finish:\n";
  $parser->{input} = uploadfile($file, $prompt);
  print $parser->Run( $debug )->str,"\n";
}

sub TERMINAL::info {
  $_[0]->{attr}
}

__PACKAGE__->main unless caller();

=head1 THE TYPENAME-IDENTIFIER PROBLEM WHEN PARSING THE C<C> LANGUAGE

The C language has a context dependency: the way an identifier is used depends
on what its current meaning is. For example, consider this:

  T(x);

This looks like a function call statement, but if C<T> is a typedef name, then
this is actually a declaration of C<x>. How can a parser for C decide how to
parse this input?

Here is another example:

  {
    T * x;
    ...
  }

What is this, a declaration of C<x> as a pointer to C<T>, 
or a void multiplication of the variables C<T> and C<x>?

The usual method to solve this problem is to have two different token types, C<ID> and C<TYPENAME>.
When the lexer finds an identifier, it looks up in the symbol table 
the current declaration of the identifier in order to 
decide which token type to return: C<TYPENAME> if the
identifier is declared as a typedef, C<ID> otherwise.

=head1 THIS EXAMPLE

One way to handle context-dependency is the lexical tie-in: a flag which is set
by the semantic actions, whose purpose is to alter the way tokens are parsed.

In this "Calc"-like example we have a language with a special construct C<hex
(hex-expr)>. After the keyword C<hex> comes an C<expression> in parentheses in
which all integers are hexadecimal. In particular, strings in C</[A-F0-9]+/>
like C<A1B> must be treated as an hex integer unless they were previously
declared.

Here the lexer looks at the value of hexflag; when it is nonzero,
all integers are parsed in hexadecimal, and tokens starting with letters are
parsed as integers if possible.

The declaration of hexflag shown in the declarations section of the parser
file is needed to make it accessible to the actions. 

=head1 SEE ALSO

=over 2

=item * L<http://www.gnu.org/software/bison/manual/html_mono/bison.html#Lexical-Tie_002dins>

=item * L<http://en.wikipedia.org/wiki/The_lexer_hack>

=item * L<http://eli.thegreenplace.net/2007/11/24/the-context-sensitivity-of-cs-grammar/>

=back
