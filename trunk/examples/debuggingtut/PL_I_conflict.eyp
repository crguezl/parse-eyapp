%{
=head1 SYNOPSIS

This grammar deals with the famous ambiguous PL/I phrase:

                if then=if then if=then

The (partial) solution uses C<YYExpect> in the lexical analyzer to predict the token
that fulfills the parser expectatives.

Compile it with:

               eyapp -b '' PL_I_conflict.eyp

Run it with;

               ./PL_I_conflict.pm -t

or

               ./PL_I_conflict.pm -d -t

=cut

use base q{DebugTail}; 
use List::Util qw{first};

%}

%strict

%token ID 

%tree bypass
%%
stmt: 
    ifstmt 
  | assignstmt
;

# Exercise: change this production 
#     for 'if' expr 'then' stmt
# and check with input 'if then=if then if=then'. The problem arises again
ifstmt: 
     %name IF
    'if' expr 'then' expr 
;

assignstmt: 
    id '=' expr
;

expr:
    %name EQ
    id '=' id
  | id
;

id: 
    %name ID
    ID
;

%%

# Returns true if $element is in the list
sub is_in($@) {
  my $element = shift;

  return first { $_ eq $element } @_;
}

# Adaptative lexer
__PACKAGE__->lexer(
  sub {
  my $parser = shift;

  for (${$parser->input()}) {    # contextualize
    m{\G\s*(\#.*)?}gc;

    m{\G([a-zA-Z_]\w*)}gc and do {
      my $id = $1;

      return ('if',   'if')   if ($id eq 'if')   && is_in('if', $parser->YYExpect);
      return ('then', 'then') if ($id eq 'then') && is_in('then', $parser->YYExpect);
      
      return ('ID', $id);
    };

    m{\G(.)}gc         and return ($1, $1);

    return('',undef);
  }
}
);

my $prompt = 'Try input "if then=if then if=then" '.
             '(press <CR><CTRL-D> to finish): ';
__PACKAGE__->main($prompt) unless caller();

