Hello Mr. Rodriguez-Leon,

       I've been testing using Perl-Eyapp to parse Linux log file entries.
My test case is a firewall log from one of our servers that is 236554
entries of three different formats:

Linux Firewall
--------------
2008 May 15 00:00:19 Main-InstaGate-604 PF Global DROP: IN=eth3 OUT=
MAC=ff:ff:ff:ff:ff:ff:00:01:4e:00:f7:6e:08:00 SRC=199.45.143.254
DST=199.45.143.255 LEN=184 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=UDP
SPT=32777 DPT=694 LEN=164

Tcplog open and close
----------------------
2008 May 15 23:59:55 Main-InstaGate-604 tcplog[d7fe2080]: Connection opened,
10.10.253.18:4480 -> 67.217.65.244:443
2008 May 15 23:59:55 Main-InstaGate-604 tcplog[d7fe2080]: Connection closed,
sent 123, recieved 86

       When I time how long it takes to process this using Eyapp, the
timing averages like this:

0 Definitions (no matches)              10s
1 Definition (Linux Firewall)           286s
2 Definition (tcp open)                 311s
3 Definition (tcp close)                316s

       If you wouldn't mind, could you review my code and language to
ensure that I'm writing it properly and provide me with answers for the
following questions:

1.      Is this expected performance for this kind of processing?
2.      Do you have any suggestions for improving the speed of processing?
3.      Would you expect the performance to climb with additional log
definitions or would it eventually "settle"?

       My Perl code (including timing with Time::HiRes) is like this:

use firewall;
my( $FirewallParser ) = new firewall;

...

$t0 = [Time::HiRes::gettimeofday];
$FirewallParser->YYData->{INPUT} = $entry;
my $t = $FirewallParser->Run();
if( !defined( $TimedEvals{eyapp} ) ){
       $TimedEvals{eyapp} = 0;
}
$TimedEvals{eyapp} += Time::HiRes::tv_interval( $t0 );

       Where $entry is a line from the log.  My language for this is at the
end of the file:


 Here is my language:
%%
log: fw | tcplog;
fw: syslogdate 'S' hostname 'S' process ':' fwdatas;
tcplog:
       syslogdate 'S' hostname 'S' tcplogid tcplogopen |
       syslogdate 'S' hostname 'S' tcplogid tcplogclose;

fwdatas: fwdata +;
fwdata: 'S' 'KEYPAIR' | 'S' 'ALPHA' | 'S';

tcplogid: 'TCPLOG' 'OPENPAREN' 'HEXID8' 'CLOSEPAREN' ':' 'S' { print
'Process:'.$_[1].' '.$_[2].' '.$_[3]."\n"; 'Process:'.$_[1].' '.$_[2].'
'.$_[3] };
tcplogopen: 'ALPHA' 'S' 'ALPHA' ',' 'S'  ip ':' port 'S' '-' '>' 'S' ip ':'
port;
tcplogclose: 'ALPHA' 'S' 'ALPHA' ',' 'S' 'ALPHA' 'S' 'INT' ',' 'S' 'ALPHA'
'S' 'INT';

syslogdate: year 'S' month 'S' day 'S' time { $_[1].' '.$_[2].' '.$_[3].'
'.$_[4] };
year: 'INT';
month: 'ALPHA';
day: 'INT';
time: 'INT' ':' 'INT' ':' 'INT';

hostname: 'ALPHA' '-' 'ALPHA' '-' 'INT' { print
'hostname:'.$_[1].'-'.$_[2].'-'.$_[3];
'hostname:'.$_[1].'-'.$_[2].'-'.$_[3]; };

process: 'ALPHA' 'S' 'ALPHA' 'S' 'ALPHA' { print 'Process:'.$_[1].'
'.$_[2].' '.$_[3]."\n"; 'Process:'.$_[1].' '.$_[2].' '.$_[3] };


port: 'INT' { 'Port:'.$_[1]} ;
ip: 'INT' '.' 'INT' '.' 'INT' '.' 'INT' {
'IP:'.$_[1].'.'.$_[3].'.'.$_[5].'.'.$_[7] };

%%
sub _Error{
       and do {
               print $_[0]->YYData->{ERRMSG};
               delete $_[0]->YYData->{ERRMSG};
               return;
       };
       print "Syntax error.\n";
}

sub _Lexer{
       my($parser) = shift;

       $parser->YYData->{INPUT}
               or $parser->YYData->{INPUT} = <STDIN>
               or return ('', undef);

       for( $parser->YYData->{INPUT} ){
               m{\G(tcplog)}gc &&              return ( 'TCPLOG', $1 );
               m{\G([0-9a-f]{8})}gc && return ( 'HEXID8', $1 );

               m{\G([\[\(])}gc &&              return( 'OPENPAREN', $1);
               m{\G([\]\)])}gc &&              return( 'CLOSEPAREN', $1 );

               m{\G([0-9]+)}gc &&              return( 'INT', $1 );
               m{\G([^\s]+\=[^\s]*)}gc &&              return( 'KEYPAIR',
$1 );
               m{\G([A-za-z]+)}gc &&   return( 'ALPHA', $1 );
               m{\G(\s+)+}gc &&                return( 'S', ' ');
               m{\G(:)}gc &&                   return ( ':', $1 );
               m{\G(-)}gc &&                   return ( '-', $1 );
               m{\G(>)}gc &&                   return ( '>', $1 );
               m{\G(,)}gc &&                   return ( ',', $1 );
               m{\G(\.)}gc &&                  return ( '.', $1 );
       }
       return( '', undef );
}

sub Run{
       my ($self) = shift;
       return $self->YYParse(
               yylex =>        \&_Lexer,
               yyerror =>      \&_Error,
       );
}


Thank you very much!

 Chris Blaise
